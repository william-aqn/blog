---
layout: post
title: "Исследуем патчи в DLL"
description: "Декомпиляция"
tags: hach hex patch
---

# Исследуем патчи в DLL
Что делать, если нужная программа обновилась, а купить не представляется возможным, из-за санкций?
Правильно - исследуем существующие методы обхода в предыдущих версиях.

Сначала нахожу оригинал DLL и её пропатченную версию. Сравниваю через **hex редактор**.
![hex_diff_dll](/assets/blog/patch/hex_diff_dll.webp)

Очень сильно был удивлён, что всего **1 изменение в 1 месте**! Теперь нужно понять, а что же скрывается за этим, что бы найти такое же, но в новой версии.

Поможет нам в этом [dnSpy](https://github.com/dnSpy/dnSpy/releases)
![dn-spy-inspect](/assets/blog/patch/dn-spy-inspect.webp)

Идём по найденному hex адресу **0x0003DB65**
![dn-spy-goto](/assets/blog/patch/dn-spy-goto.webp)

Смотрим что там скрывается - это функция регистрации, что логично.
![dn-spy-detail](/assets/blog/patch/dn-spy-detail.webp)

А что конкретно означает **17**?
![dn-spy-17](/assets/blog/patch/dn-spy-17.webp)

Открываем в том же месте **пропатченную DLL**, смотрим что же такое **2А**

![dn-spy-2a](/assets/blog/patch/dn-spy-2a.webp)

Очень элегантное решение, просто сделать **return** перед всеми проверками! Теперь функция регистрации,по мнению декомпилятора, выглядит вот так. Хотя не вырезали никакого кода, просто поменяли 1 инструкцию внутри функции.
![dn-spy-return](/assets/blog/patch/dn-spy-return.webp)

Потом по образу и подобию находим новое смещение в новой версии DLL и всё работает :)

Теперь для автоматизации возьмём начало функции в **hex формате** и в конце будет искомое число
```
0228CF1700066FAA02000A2C300228CF17000612011F0E1728F300000A120172213F017028F400000A120103285105002B120128F600000A6FAC02000A17
```

Навайбкодим [небольшой скрипт hex патчера](https://github.com/william-aqn/hex-auto-patcher) и теперь, до тех пор, пока разработчики что то не поменяют в этой DLL, обход активации будет срабатывать.

*Любые названия библиотек и hex случайны и материал несёт исключительно познавательный характер.*